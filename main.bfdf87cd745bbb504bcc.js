/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkwidget_mobile_controller"] = self["webpackChunkwidget_mobile_controller"] || []).push([["main"],{

/***/ "./src/MobileWidgetCameraControls.js":
/*!*******************************************!*\
  !*** ./src/MobileWidgetCameraControls.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MobileWidgetCameraControls\": () => /* binding */ MobileWidgetCameraControls\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _MobileWidgetControls__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MobileWidgetControls */ \"./src/MobileWidgetControls.js\");\n/**\n * (c) madblade 2020\n * https://creativecommons.org/licenses/by/3.0/\n * -- please consider giving credit --\n */\n\n\n/**\n * THREE.JS mobile camera FPS control.\n * @param element\n *      HTML element used to draw the canvas.\n *      For example a\n *      <div id=\"widget\"> just under the body tag.\n * @param camera\n *      Three.JS PerspectiveCamera.\n * @param controlsType\n *      'quaternion' for unconstrained Quaternion.\n *      'spherical' for XZ-constrained Euler angles\n *          (better for games where the player stays up).\n *      Feel free to adapt to your needs.\n * @param controlsTheme\n *      Supported themes:\n *      'playstation', 'xbox', 'default'\n * @constructor\n */\n\nvar MobileWidgetCameraControls = function MobileWidgetCameraControls(element, camera, controlsType, controlsTheme) {\n  var _this = this;\n\n  this.camera = camera;\n  this.controlsType = controlsType;\n  this.cameraMovementSpeed = 1 / 4;\n  this.cameraRotationSpeed = 1 / 75; // Stick states\n\n  this.leftX = 0;\n  this.leftY = 0;\n  this.rightX = 0;\n  this.rightY = 0; // For Euler-type controls\n\n  this.rx = 0;\n  this.ry = 0; // Callbacks\n\n  var onLeftStickMove = function onLeftStickMove(x, y) {\n    _this.leftX = x;\n    _this.leftY = y;\n  };\n\n  var onRightStickMove = function onRightStickMove(x, y) {\n    _this.rightX = x;\n    _this.rightY = y;\n  };\n\n  var onButtonChange = function onButtonChange(which, isHeld) {\n    console.log(\"Button \".concat(which, \" \").concat(isHeld ? 'pressed' : 'released', \".\"));\n  };\n\n  this.widgetControls = new _MobileWidgetControls__WEBPACK_IMPORTED_MODULE_0__.MobileWidgetControls(element, onLeftStickMove, onRightStickMove, onButtonChange, controlsTheme || 'default'); // Prevent user from selecting text while moving fingers about.\n\n  this.widgetControls.makeDocumentUnselectable();\n};\n/**\n * animation utility function\n * !!!To be called at every playable/gameplay-refresh frame!!!\n */\n\n\nMobileWidgetCameraControls.prototype.animate = function () {\n  // 1. Camera rotation.\n  var cameraRotationSpeed = this.cameraRotationSpeed;\n  var deltaX = this.rightX * cameraRotationSpeed;\n  var deltaZ = this.rightY * cameraRotationSpeed;\n\n  switch (this.controlsType) {\n    case 'quaternion':\n      var q = new three__WEBPACK_IMPORTED_MODULE_1__.Quaternion();\n\n      if (Math.abs(deltaZ) > 0) {\n        q.set(-deltaZ, 0, 0, 1).normalize();\n        this.camera.quaternion.multiply(q);\n      }\n\n      if (Math.abs(deltaX) > 0) {\n        q.set(0, -deltaX, 0, 1).normalize();\n        this.camera.quaternion.multiply(q);\n      }\n\n      break;\n\n    case 'spherical':\n      if (Math.abs(deltaZ) > 0) {\n        this.rx -= deltaZ * 2; // More convenient rotation without lock\n        // if (this.rx > 3 * Math.PI / 2) this.rx -= 2 * Math.PI;\n        // if (this.rx < -3 * Math.PI / 2) this.rx += 2 * Math.PI;\n\n        this.rx = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.rx));\n        this.updateQuaternionFromRotation();\n      }\n\n      if (Math.abs(deltaX) > 0) {\n        if (this.rx < -Math.PI / 2 || this.rx > Math.PI / 2) this.ry += deltaX * 2;else this.ry -= deltaX * 2;\n        this.updateQuaternionFromRotation();\n      }\n\n      break;\n\n    default:\n      break;\n  } // 2. Camera movement.\n\n\n  var cameraMovementSpeed = this.cameraMovementSpeed;\n  var dx = this.leftX * cameraMovementSpeed;\n  var dy = this.leftY * cameraMovementSpeed;\n  var forwardVector = this.getForwardVector(dx, -dy);\n  this.camera.position.x += forwardVector.x * cameraMovementSpeed;\n  this.camera.position.z += forwardVector.z * cameraMovementSpeed; // Projection on the (xz) plane if not quaternion.\n\n  if (this.controlsType === 'quaternion') {\n    this.camera.position.y += forwardVector.y * cameraMovementSpeed;\n  } // 3. Update gamepad model.\n\n\n  this.widgetControls.animate();\n};\n\nMobileWidgetCameraControls.prototype.updateQuaternionFromRotation = function () {\n  var q1 = new three__WEBPACK_IMPORTED_MODULE_1__.Quaternion();\n  var q2 = new three__WEBPACK_IMPORTED_MODULE_1__.Quaternion();\n  q1.setFromAxisAngle(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 0, 0), this.rx);\n  q2.setFromAxisAngle(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 1, 0), this.ry);\n  q2.multiply(q1);\n  this.camera.quaternion.copy(q2);\n};\n\nMobileWidgetCameraControls.prototype.getForwardVector = function (x, y) {\n  var nv = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(x, 0, -y);\n  nv.normalize();\n  var camQ = new three__WEBPACK_IMPORTED_MODULE_1__.Quaternion();\n  this.camera.getWorldQuaternion(camQ);\n  nv.applyQuaternion(camQ);\n  return nv;\n};\n\n\n\n//# sourceURL=webpack://widget-mobile-controller/./src/MobileWidgetCameraControls.js?");

/***/ }),

/***/ "./src/MobileWidgetControls.js":
/*!*************************************!*\
  !*** ./src/MobileWidgetControls.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MobileWidgetControls\": () => /* binding */ MobileWidgetControls\n/* harmony export */ });\n/**\n * (c) madblade 2020\n * https://creativecommons.org/licenses/by/3.0/\n * -- please consider giving credit --\n */\n\n/**\n * Mobile Widget Controller\n * @param element HTMLElement used to get touch events and to draw the widget.\n * @param onLeftStickMove function(X, Y) from the stick center.\n * @param onRightStickMove function(X, Y) from the stick center.\n * @param onButtonPress function(whichButton) for additional buttons.\n * @param controllerType 'playstation,' 'xbox,' 'default'\n * @constructor\n */\nvar MobileWidgetControls = function MobileWidgetControls(element, onLeftStickMove, onRightStickMove, onButtonPress, controllerType) {\n  var _this = this;\n\n  if (!(element instanceof HTMLElement)) throw Error('[MobileWidgetControls] Expected element to be an HTMLElement.');\n  var isTouch = 'ontouchstart' in window || navigator.msMaxTouchPoints > 0; // if (!isTouch)\n  //     throw Error('[MobileWidgetControls] Device does not appear to support touch events.');\n\n  var w = window.innerWidth;\n  var h = window.innerHeight;\n  var dpr = window.devicePixelRatio; // Overflow causes an ugly y shift (the size of the bar).\n\n  document.body.style.overflowX = 'hidden';\n  document.body.style.overflowY = 'hidden'; // Main objects.\n\n  this.element = element;\n  this.leftStickMoveCallback = onLeftStickMove;\n  this.rightStickMoveCallback = onRightStickMove;\n  this.buttonPressCallback = onButtonPress;\n  this.controllerType = controllerType ? controllerType : 'default'; // Device pixel ratio trick to correctly initialize the model on mobile\n  // (where zooming is disabled)\n  // and to keep the model the right size when zooming on desktop.\n\n  this.currentDPR = dpr;\n  this.initialDPR = dpr;\n  this.CANVAS_ID = 'widget-drawing-canvas';\n  this.TIME_MS_TO_GET_TO_ORIGINAL_POSITION = 60; // 60ms to relax\n\n  this.minOpacity = 0.1; // Model\n\n  this.leftStick = {};\n  this.rightStick = {};\n  this.buttons = [];\n  this.fingers = []; // Graphics.\n\n  var c = document.getElementById(this.CANVAS_ID);\n\n  if (!c) {\n    this.canvas = document.createElement('canvas');\n    this.canvas.setAttribute('id', this.CANVAS_ID);\n    this.canvas.setAttribute('width', \"\".concat(w));\n    this.canvas.setAttribute('height', \"\".concat(h));\n    this.canvas.setAttribute('style', 'position: absolute; width: 100%; bottom: 0px; z-index: 999;');\n    this.element.appendChild(this.canvas);\n  } else {\n    this.canvas = c;\n  } // Listeners.\n  // Emulate touch with mouse on desktop.\n\n\n  if (!isTouch) {\n    this.element.addEventListener('mousemove', function (e) {\n      return _this.updateMove(e);\n    });\n    this.element.addEventListener('mousedown', function (e) {\n      return _this.updateDown(e);\n    });\n    this.element.addEventListener('mouseup', function (e) {\n      return _this.updateUp(e);\n    });\n  } // Rescale canvas and event/drawable coordinates with devicePixelRatio.\n\n\n  window.addEventListener('resize', function () {\n    return _this.resize();\n  });\n  window.addEventListener('orientationchange', function () {\n    return _this.resize();\n  }); // Main listener.\n\n  var touchListener = function touchListener(k) {\n    return function (e) {\n      if (k === 'start') e.preventDefault();\n\n      if (k === 'move') {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n\n      _this.fingers = [];\n\n      if (k === 'cancel') {\n        console.error('[MobileWidgetControls] Too many fingers or unsupported action.');\n        return;\n      } // Update finger model.\n\n\n      var touches = e.touches;\n\n      for (var i = 0; i < touches.length; ++i) {\n        var touch = touches[i];\n        var x = touch.clientX;\n        var y = touch.clientY;\n\n        _this.fingers.push({\n          x: x,\n          y: y\n        });\n      } // Update controller model.\n\n\n      var changedTouches = e.changedTouches;\n\n      for (var _i = 0; _i < changedTouches.length; ++_i) {\n        var _touch = changedTouches[_i];\n        if (k === 'end') _this.updateUp(_touch);else if (k === 'move') _this.updateMove(_touch);else if (k === 'start') _this.updateDown(_touch);\n      }\n    };\n  }; // Binding to the actual events.\n\n\n  this.canvas.addEventListener('touchstart', touchListener('start'), false);\n  this.canvas.addEventListener('touchmove', touchListener('move'), false);\n  this.canvas.addEventListener('touchend', touchListener('end'), false);\n  this.canvas.addEventListener('touchcancel', touchListener('cancel'), false); // Internal.\n\n  this._resizeRequest = null; // Model init.\n\n  this.init();\n};\n\nMobileWidgetControls.prototype.init = function () {\n  var h = window.innerHeight;\n  var w = window.innerWidth; // Resize canvas style.\n\n  this.canvas.style.width = \"\".concat(w, \"px\");\n  this.canvas.style.height = \"\".concat(h, \"px\"); // Resize model for css.\n\n  var dpr = window.devicePixelRatio;\n\n  if (dpr !== this.currentDPR) {\n    // Update (because of zoom)\n    console.log('[MobileWidgetControls] Zoom triggered: updating DPR.');\n    this.currentDPR = dpr;\n  }\n\n  var dw = dpr * w;\n  var dh = dpr * h;\n  this.canvas.width = dw;\n  this.canvas.height = dh; // No need to resize the model of whatever is gonna be drawn inside the canvas.\n  // Event X and Y are going to be rescaled.\n  // .\n\n  var controllerType = this.controllerType;\n  this.initButtons(controllerType, dw, dh);\n  this.initSticks(controllerType, dw, dh); // Refresh graphics.\n\n  this.draw();\n};\n/* BUTTONS */\n// button order: see https://www.w3.org/TR/gamepad/\n// https://patents.google.com/patent/US20130215024A1/en\n\n\nMobileWidgetControls.PlaystationControllerButtons = [{\n  name: 'cross',\n  from: 'r',\n  x: 85,\n  y: 75,\n  label: String.fromCharCode(10761),\n  labelSize: 30,\n  diameter: 30,\n  labelOffset: 2,\n  theme: 'gradient'\n}, {\n  name: 'circle',\n  from: 'r',\n  x: 40,\n  y: 120,\n  labelSize: 23,\n  diameter: 30,\n  label: String.fromCharCode(9711),\n  labelOffset: 2,\n  theme: 'gradient'\n}, {\n  name: 'square',\n  from: 'r',\n  x: 130,\n  y: 120,\n  labelSize: 36,\n  diameter: 30,\n  label: String.fromCharCode(9723),\n  labelOffset: 2,\n  theme: 'gradient'\n}, {\n  name: 'triangle',\n  from: 'r',\n  x: 85,\n  y: 165,\n  labelSize: 35,\n  diameter: 30,\n  label: String.fromCharCode(9651),\n  labelOffset: 0,\n  theme: 'gradient'\n}, {\n  name: 'L1',\n  from: 'l',\n  x: 110,\n  y: 260,\n  labelSize: 30,\n  diameter: 30,\n  label: 'L1',\n  labelOffset: 3,\n  theme: 'gradient'\n}, {\n  name: 'R1',\n  from: 'r',\n  x: 110,\n  y: 260,\n  labelSize: 30,\n  diameter: 30,\n  label: 'R1',\n  labelOffset: 3,\n  theme: 'gradient'\n}, {\n  name: 'L2',\n  from: 'l',\n  x: 50,\n  y: 280,\n  labelSize: 30,\n  diameter: 30,\n  label: 'L2',\n  labelOffset: 3,\n  theme: 'gradient'\n}, {\n  name: 'R2',\n  from: 'r',\n  x: 50,\n  y: 280,\n  labelSize: 30,\n  diameter: 30,\n  label: 'R2',\n  labelOffset: 3,\n  theme: 'gradient'\n}, {\n  name: 'back'\n}, // select\n{\n  name: 'forward'\n}, // start\n{\n  name: 'stickLB'\n}, // click on stick\n{\n  name: 'stickRB'\n}, // click on stick\n{\n  name: 'dpadUp',\n  from: 'l',\n  x: 65,\n  y: 205,\n  label: String.fromCharCode(8593),\n  labelSize: 20,\n  diameter: 23,\n  labelOffset: 0,\n  theme: 'gradient'\n}, {\n  name: 'dpadDown',\n  from: 'l',\n  x: 65,\n  y: 135,\n  label: String.fromCharCode(8595),\n  labelSize: 20,\n  diameter: 23,\n  labelOffset: 0,\n  theme: 'gradient'\n}, {\n  name: 'dpadLeft',\n  from: 'l',\n  x: 30,\n  y: 170,\n  label: String.fromCharCode(8592),\n  labelSize: 20,\n  diameter: 23,\n  labelOffset: 0,\n  theme: 'gradient'\n}, {\n  name: 'dpadRight',\n  from: 'l',\n  x: 100,\n  y: 170,\n  label: String.fromCharCode(8594),\n  labelSize: 20,\n  diameter: 23,\n  labelOffset: 0,\n  theme: 'gradient'\n}, {\n  name: 'home' // from: 'l', x: 300, y: 150,\n  // label: 'PS',\n  // labelSize: 10, diameter: 20,\n  // labelOffset: 2,\n  // theme: 'gradient'\n\n}]; // https://patents.google.com/patent/US8641525B2/en\n\nMobileWidgetControls.XBoxControllerButtons = [{\n  name: 'A',\n  from: 'r',\n  diameter: 25,\n  x: 80,\n  y: 35,\n  label: 'A',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: 'B',\n  from: 'r',\n  diameter: 25,\n  x: 45,\n  y: 75,\n  label: 'B',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: 'X',\n  from: 'r',\n  diameter: 25,\n  x: 115,\n  y: 75,\n  label: 'X',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: 'Y',\n  from: 'r',\n  diameter: 25,\n  x: 80,\n  y: 115,\n  label: 'Y',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: 'LB',\n  from: 'l',\n  diameter: 35,\n  x: 135,\n  y: 205,\n  label: 'LB',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: 'RB',\n  from: 'r',\n  diameter: 35,\n  x: 130,\n  y: 180,\n  label: 'RB',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: 'LT',\n  from: 'l',\n  diameter: 35,\n  x: 45,\n  y: 210,\n  label: 'LT',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: 'RT',\n  from: 'r',\n  diameter: 35,\n  x: 45,\n  y: 200,\n  label: 'RT',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: 'back'\n}, // select\n{\n  name: 'forward'\n}, // start\n{\n  name: 'stickLB'\n}, {\n  name: 'stickRB'\n}, {\n  name: 'dpadUp',\n  from: 'l',\n  diameter: 15,\n  x: 220,\n  y: 73,\n  label: String.fromCharCode(8593),\n  labelSize: 20,\n  labelOffset: 0\n}, {\n  name: 'dpadDown',\n  from: 'l',\n  diameter: 15,\n  x: 220,\n  y: 27,\n  label: String.fromCharCode(8595),\n  labelSize: 20,\n  labelOffset: 0\n}, {\n  name: 'dpadLeft',\n  from: 'l',\n  diameter: 15,\n  x: 197,\n  y: 50,\n  label: String.fromCharCode(8592),\n  labelSize: 20,\n  labelOffset: 0\n}, {\n  name: 'dpadRight',\n  x: 243,\n  y: 50,\n  from: 'l',\n  diameter: 15,\n  label: String.fromCharCode(8594),\n  labelSize: 20,\n  labelOffset: 0\n}, {\n  name: 'home'\n}];\n\nMobileWidgetControls.prototype.initButtons = function (controllerType, dw, dh) {\n  var buttons;\n\n  switch (controllerType) {\n    case 'playstation':\n      buttons = MobileWidgetControls.PlaystationControllerButtons;\n      break;\n\n    case 'xbox':\n      buttons = MobileWidgetControls.XBoxControllerButtons;\n      break;\n\n    default:\n      // No buttons.\n      return;\n  }\n\n  var dpr = this.initialDPR;\n  var modelButtons = [];\n\n  for (var bid in buttons) {\n    if (!buttons.hasOwnProperty(bid)) continue;\n    var reference = buttons[bid];\n    if (!reference.x || !reference.y || !reference.diameter) continue;\n\n    if (!reference.name) {\n      console.error('[MobileWidgetControls] A button must have a name property.');\n    }\n\n    var button = {}; // model\n\n    button.held = false;\n    button.id = reference.name; // mandatory graphics\n\n    button.modelOriginX = reference.from === 'l' ? dpr * reference.x : dw - dpr * reference.x;\n    button.modelOriginY = dh - dpr * reference.y;\n    button.BUTTON_DIAMETER = dpr * reference.diameter;\n    button.style = reference.theme; // optional\n\n    button.BUTTON_LABEL = reference.label;\n    button.BUTTON_LABEL_SIZE = dpr * reference.labelSize;\n    button.BUTTON_LABEL_OFFSET = dpr * reference.labelOffset;\n    modelButtons.push(button);\n  }\n\n  this.buttons = modelButtons;\n};\n\nMobileWidgetControls.prototype.notifyButtonChanged = function (button, isHolding) {\n  if (this.buttonPressCallback) this.buttonPressCallback(button.id, isHolding);\n};\n\nMobileWidgetControls.prototype.updateButtonModelHold = function (cx, cy, buttons, isHolding) {\n  var hasHitButton = false;\n\n  for (var i = 0, n = buttons.length; i < n; ++i) {\n    // Get first hit button.\n    var b = buttons[i];\n    var d = this.distanceToObjectCenter(cx, cy, b);\n    if (d > b.BUTTON_DIAMETER) continue; // Button hit.\n\n    hasHitButton = true;\n\n    if (b.held !== isHolding) {\n      // console.log(`Button ${b.id} ${isHolding ? 'touched' : 'released'}.`);\n      b.held = isHolding; // Propagate event.\n\n      this.notifyButtonChanged(b, isHolding);\n    }\n\n    break;\n  }\n\n  return hasHitButton;\n};\n\nMobileWidgetControls.prototype.updateButtonModelMove = function (cx, cy, buttons) {\n  var hasReleasedButton = false;\n\n  for (var i = 0, n = buttons.length; i < n; ++i) {\n    // Get all buttons that are not touched.\n    var b = buttons[i];\n    if (!b.held) continue; // b wasn’t held.\n\n    var d = this.distanceToObjectCenter(cx, cy, b);\n    if (d < b.BUTTON_DIAMETER) continue; // b wasn’t under finger.\n    // Test b against every finger.\n\n    var isUnderAnotherFinger = false;\n    var fs = this.fingers;\n    var dpr = this.currentDPR;\n\n    for (var j = 0; j < fs.length; ++j) {\n      var f = fs[j];\n      var d2 = this.distanceToObjectCenter(dpr * f.x, dpr * f.y, b);\n\n      if (d2 < b.BUTTON_DIAMETER) {\n        isUnderAnotherFinger = true;\n        break;\n      }\n    }\n\n    if (isUnderAnotherFinger) continue; // b is under finger, but another one.\n\n    hasReleasedButton = true; // console.log(`Button ${b.id} released.`);\n\n    b.held = false; // Propagate.\n\n    this.notifyButtonChanged(b, false);\n  }\n\n  return hasReleasedButton;\n};\n\nMobileWidgetControls.prototype.drawButton = function (ctx, button) {\n  // Background\n  ctx.beginPath();\n  ctx.globalAlpha = this.minOpacity + 0.2;\n  var originXLeft = button.modelOriginX;\n  var originYLeft = button.modelOriginY;\n  ctx.arc(originXLeft, originYLeft, button.BUTTON_DIAMETER, 0, 2 * Math.PI); // ctx.fillStyle = button.held ? '#222222' : 'black';\n\n  if (button.style === 'gradient') {\n    var gradient = ctx.createRadialGradient(originXLeft, originYLeft, 2, // inner\n    originXLeft, originYLeft, button.BUTTON_DIAMETER // outer\n    );\n    gradient.addColorStop(0, button.held ? 'silver' : 'black');\n    gradient.addColorStop(0.7, button.held ? 'silver' : 'black');\n    gradient.addColorStop(0.9, 'silver');\n    gradient.addColorStop(1, 'silver');\n    ctx.fillStyle = gradient;\n  } else {\n    ctx.fillStyle = button.held ? '#222222' : 'black';\n  }\n\n  ctx.fill();\n\n  if (button.style !== 'gradient') {\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = 'white';\n    ctx.stroke();\n  }\n\n  ctx.closePath(); // Label\n\n  ctx.beginPath();\n  ctx.font = \"\".concat(button.BUTTON_LABEL_SIZE, \"px Arial\");\n  ctx.fillStyle = 'white';\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n  ctx.globalAlpha = this.minOpacity + 0.3;\n  ctx.fillText(button.BUTTON_LABEL, originXLeft, originYLeft + (button.BUTTON_LABEL_OFFSET || 0)); // ctx.fill();\n  // ctx.lineWidth = 2;\n  // ctx.strokeStyle = 'white';\n  // ctx.stroke();\n\n  ctx.closePath();\n};\n/* STICKS */\n\n\nMobileWidgetControls.DefaultSticks = [{\n  name: 'left',\n  from: 'l',\n  x: 100,\n  y: 120,\n  head: 25,\n  base: 70,\n  grab: 150,\n  reach: 55,\n  label: String.fromCharCode(10021),\n  // multi-directional cross\n  labelSize: 30,\n  labelOffset: 2,\n  // offset i.e. for caps letters\n  theme: 'gradient'\n}, {\n  name: 'right',\n  from: 'r',\n  x: 100,\n  y: 120,\n  head: 25,\n  base: 70,\n  grab: 150,\n  reach: 55,\n  label: String.fromCharCode(10021),\n  // multi-directional cross\n  labelSize: 30,\n  labelOffset: 2,\n  // offset i.e. for caps letters\n  theme: 'gradient'\n}];\nMobileWidgetControls.PlaystationSticks = [{\n  name: 'left',\n  from: 'l',\n  x: 155,\n  y: 80,\n  head: 25,\n  base: 70,\n  grab: 150,\n  reach: 55,\n  theme: 'gradient'\n}, {\n  name: 'right',\n  from: 'r',\n  x: 240,\n  y: 100,\n  head: 25,\n  base: 70,\n  grab: 150,\n  reach: 55,\n  // label: String.fromCharCode(10021), // multi-directional cross\n  // labelSize: 30,\n  // labelOffset: 2, // offset i.e. for caps letters\n  theme: 'gradient'\n}];\nMobileWidgetControls.XBoxSticks = [{\n  name: 'left',\n  from: 'l',\n  x: 90,\n  y: 90,\n  head: 35,\n  base: 80,\n  grab: 150,\n  reach: 65,\n  theme: 'dark'\n}, {\n  name: 'right',\n  from: 'r',\n  x: 240,\n  y: 80,\n  head: 30,\n  base: 70,\n  grab: 130,\n  reach: 55,\n  theme: 'dark'\n}];\n\nMobileWidgetControls.prototype.initStick = function (dw, dh, stick, reference) {\n  var dpr = this.initialDPR;\n  stick.x = stick.y = stick.lastHeldX = stick.lastHeldY = stick.timeStampReleased = 0;\n  stick.modelOriginX = reference.from === 'l' ? dpr * reference.x : dw - dpr * reference.x;\n  stick.modelOriginY = dh - dpr * reference.y;\n  stick.held = !1;\n  stick.needsUpdate = !0; // graphics constants\n\n  stick.STICK_HEAD_DIAMETER = dpr * reference.head;\n  stick.STICK_BASE_DIAMETER = dpr * reference.base;\n  stick.STICK_GRAB_DISTANCE = dpr * reference.grab;\n  stick.STICK_REACH_DISTANCE = dpr * reference.reach; // optional\n\n  stick.STICK_LABEL = reference.label;\n  stick.STICK_LABEL_SIZE = dpr * reference.labelSize;\n  stick.STICK_LABEL_OFFSET = dpr * reference.labelOffset;\n  stick.style = reference.theme;\n};\n\nMobileWidgetControls.prototype.initSticks = function (controllerType, dw, dh) {\n  var sticksReference;\n\n  switch (controllerType) {\n    case 'playstation':\n      sticksReference = MobileWidgetControls.PlaystationSticks;\n      break;\n\n    case 'xbox':\n      sticksReference = MobileWidgetControls.XBoxSticks;\n      break;\n\n    default:\n      sticksReference = MobileWidgetControls.DefaultSticks;\n      break;\n  }\n\n  this.initStick(dw, dh, this.leftStick, sticksReference[0]);\n  this.initStick(dw, dh, this.rightStick, sticksReference[1]);\n};\n\nMobileWidgetControls.prototype.notifyStickMoved = function (vx, vy, stick) {\n  var normX = vx / stick.STICK_REACH_DISTANCE;\n  var normY = vy / stick.STICK_REACH_DISTANCE;\n\n  if (stick === this.leftStick) {\n    if (this.leftStickMoveCallback) this.leftStickMoveCallback(normX, normY);\n  } else if (stick === this.rightStick) {\n    if (this.rightStickMoveCallback) this.rightStickMoveCallback(normX, normY);\n  }\n};\n\nMobileWidgetControls.prototype.updateStickModelFromMove = function (cx, cy, d, stick) {\n  var vx = cx - stick.modelOriginX;\n  var vy = cy - stick.modelOriginY;\n\n  if (d > stick.STICK_REACH_DISTANCE) {\n    vx *= stick.STICK_REACH_DISTANCE / d;\n    vy *= stick.STICK_REACH_DISTANCE / d;\n  }\n\n  stick.x = vx;\n  stick.y = vy;\n  stick.lastHeldX = vx;\n  stick.lastHeldY = vy;\n  this.notifyStickMoved(vx, vy, stick);\n};\n\nMobileWidgetControls.prototype.updateStickModelMove = function (cx, cy, stick) {\n  var d = this.distanceToObjectCenter(cx, cy, stick);\n\n  if (d < stick.STICK_GRAB_DISTANCE) {\n    // stick grab\n    stick.needsUpdate = true;\n    if (stick.held) this.updateStickModelFromMove(cx, cy, d, stick);\n  } else if (stick.held) {\n    // test against every other finger\n    var stickIsHeldByAnotherFinger = false;\n    var fs = this.fingers;\n    var dpr = this.currentDPR;\n\n    for (var i = 0; i < fs.length; ++i) {\n      var f = fs[i];\n      var d2 = this.distanceToObjectCenter(dpr * f.x, dpr * f.y, stick);\n\n      if (d2 < stick.STICK_GRAB_DISTANCE) {\n        stickIsHeldByAnotherFinger = true;\n        break;\n      }\n    }\n\n    if (!stickIsHeldByAnotherFinger) {\n      // stick release\n      stick.held = false;\n      stick.needsUpdate = true;\n      this.updateStickModelFromMove(cx, cy, d, stick);\n      stick.timeStampReleased = this.getTimeInMilliseconds();\n    }\n  }\n};\n\nMobileWidgetControls.prototype.updateStickModelHold = function (cx, cy, stick, isHolding) {\n  var d = this.distanceToObjectCenter(cx, cy, stick);\n\n  if (d < stick.STICK_GRAB_DISTANCE) {\n    var wasHolding = stick.held;\n    stick.held = isHolding;\n    if (wasHolding && !isHolding) stick.timeStampReleased = this.getTimeInMilliseconds();\n    stick.needsUpdate = true;\n  }\n};\n\nMobileWidgetControls.prototype.updateMove = function (event) {\n  var dpr = this.currentDPR;\n  var cx = event.clientX * dpr;\n  var cy = event.clientY * dpr;\n  this.updateButtonModelMove(cx, cy, this.buttons);\n  this.updateStickModelMove(cx, cy, this.leftStick);\n  this.updateStickModelMove(cx, cy, this.rightStick);\n};\n\nMobileWidgetControls.prototype.getClosestStick = function (cx, cy) {\n  var dl = this.distanceToObjectCenter(cx, cy, this.leftStick);\n  var dr = this.distanceToObjectCenter(cx, cy, this.rightStick);\n  return dl <= dr ? this.leftStick : this.rightStick;\n};\n\nMobileWidgetControls.prototype.updateDown = function (event) {\n  var dpr = this.currentDPR;\n  var cx = event.clientX * dpr;\n  var cy = event.clientY * dpr;\n  var hasHitButton = this.updateButtonModelHold(cx, cy, this.buttons, true);\n  if (hasHitButton) return;\n  var stick = this.getClosestStick(cx, cy);\n  this.updateStickModelHold(cx, cy, stick, true);\n  this.updateStickModelMove(cx, cy, stick);\n};\n\nMobileWidgetControls.prototype.updateUp = function (event) {\n  var dpr = this.currentDPR;\n  var cx = dpr * event.clientX;\n  var cy = dpr * event.clientY;\n  this.updateButtonModelHold(cx, cy, this.buttons, false);\n  this.updateStickModelHold(cx, cy, this.leftStick, false);\n  this.updateStickModelHold(cx, cy, this.rightStick, false);\n};\n\nMobileWidgetControls.prototype.drawStick = function (ctx, stick) {\n  var originXLeft = stick.modelOriginX;\n  var originYLeft = stick.modelOriginY; // Base\n\n  ctx.beginPath();\n  ctx.globalAlpha = this.minOpacity;\n  ctx.arc(originXLeft, originYLeft, stick.STICK_BASE_DIAMETER, 0, 2 * Math.PI);\n\n  if (stick.style === 'gradient') {\n    var gradient = ctx.createRadialGradient(originXLeft, originYLeft, 2, // inner\n    originXLeft, originYLeft, stick.STICK_BASE_DIAMETER // outer\n    );\n    gradient.addColorStop(0, 'gray');\n    gradient.addColorStop(0.7, 'gray');\n    gradient.addColorStop(0.9, 'silver');\n    gradient.addColorStop(1, 'white');\n    ctx.fillStyle = gradient;\n  } else {\n    ctx.fillStyle = 'black';\n  }\n\n  ctx.fill();\n\n  if (stick.style !== 'gradient') {\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = 'white';\n    ctx.stroke();\n  }\n\n  ctx.closePath(); // Head\n\n  var stickXLeft = stick.x;\n  var stickYLeft = stick.y;\n  ctx.beginPath();\n  ctx.globalAlpha = this.minOpacity;\n  ctx.arc(originXLeft + stickXLeft, originYLeft + stickYLeft, stick.STICK_HEAD_DIAMETER, 0, 2 * Math.PI);\n\n  if (stick.style === 'gradient') {\n    ctx.globalAlpha = this.minOpacity + 0.05;\n\n    var _gradient = ctx.createRadialGradient(originXLeft + stickXLeft, originYLeft + stickYLeft, 2, // inner\n    originXLeft + stickXLeft, originYLeft + stickYLeft, stick.STICK_HEAD_DIAMETER // outer\n    );\n\n    _gradient.addColorStop(0, 'darkgray');\n\n    _gradient.addColorStop(0.7, 'darkgray');\n\n    _gradient.addColorStop(0.9, 'whitesmoke');\n\n    _gradient.addColorStop(1, 'white');\n\n    ctx.fillStyle = _gradient;\n  } else {\n    ctx.fillStyle = 'black';\n  }\n\n  ctx.fill();\n\n  if (stick.style !== 'gradient') {\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = 'white';\n    ctx.stroke();\n  }\n\n  ctx.closePath(); // Optional label\n\n  if (stick.STICK_LABEL && stick.STICK_LABEL_SIZE) {\n    ctx.beginPath();\n    ctx.font = \"\".concat(stick.STICK_LABEL_SIZE, \"px Arial\");\n    ctx.fillStyle = 'white';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.globalAlpha = this.minOpacity;\n    ctx.fillText(stick.STICK_LABEL, originXLeft + stickXLeft, originYLeft + stickYLeft + (stick.STICK_LABEL_OFFSET || 0));\n    ctx.closePath();\n  }\n};\n\nMobileWidgetControls.prototype.draw = function () {\n  var canvas = this.canvas;\n  var ctx = canvas.getContext('2d');\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  this.drawStick(ctx, this.leftStick);\n  this.drawStick(ctx, this.rightStick);\n  var buttons = this.buttons;\n\n  for (var i = 0, n = buttons.length; i < n; ++i) {\n    this.drawButton(ctx, buttons[i]);\n  }\n};\n\nMobileWidgetControls.prototype.interpolateStick = function (stick, newTime) {\n  var deltaT = newTime - stick.timeStampReleased;\n  var maxDeltaT = this.TIME_MS_TO_GET_TO_ORIGINAL_POSITION;\n  var t = this.smootherstep(0, maxDeltaT, deltaT);\n  var ox = stick.modelOriginX;\n  var oy = stick.modelOriginY;\n  var newX = (ox + stick.lastHeldX) * (1 - t) + ox * t - ox;\n  var newY = (oy + stick.lastHeldY) * (1 - t) + oy * t - oy;\n  if (stick.x === stick.y && stick.x === stick.y) stick.needsUpdate = false;\n  stick.x = newX;\n  stick.y = newY; // Propagate event.\n\n  if (stick.needsUpdate) this.notifyStickMoved(newX, newY, stick);\n};\n\nMobileWidgetControls.prototype.animate = function () {\n  var newTime = this.getTimeInMilliseconds();\n  var leftStick = this.leftStick;\n  if (!leftStick.held && leftStick.needsUpdate) this.interpolateStick(leftStick, newTime);\n  var rightStick = this.rightStick;\n  if (!rightStick.held && rightStick.needsUpdate) this.interpolateStick(rightStick, newTime);\n  this.draw();\n};\n\nMobileWidgetControls.prototype.resize = function () {\n  var _this2 = this;\n\n  if (this._resizeRequest) clearTimeout(this._resizeRequest);\n  this._resizeRequest = setTimeout(function () {\n    //\n    // On recent iOS Safari, open tabs create an offset\n    window.scrollTo(0, document.body.scrollHeight); // Recompute everything.\n\n    _this2.init();\n  }, 100 // Don’t resize every frame.\n  );\n};\n/* UTIL */\n\n\nMobileWidgetControls.prototype.getTimeInMilliseconds = function () {\n  return performance.now();\n};\n\nMobileWidgetControls.prototype.distanceToObjectCenter = function (cx, cy, object) {\n  return Math.sqrt(Math.pow(cx - object.modelOriginX, 2) + Math.pow(cy - object.modelOriginY, 2));\n};\n\nMobileWidgetControls.prototype.clamp = function (t, low, high) {\n  return Math.min(high, Math.max(low, t));\n}; // MobileWidgetControls.prototype.smoothstep = function(end1, end2, t)\n// {\n//     let x = this.clamp((t - end1) / (end2 - end1), 0.0, 1.0);\n//     return x * x * (3 - 2 * x);\n// };\n\n\nMobileWidgetControls.prototype.smootherstep = function (end1, end2, t) {\n  var x = this.clamp((t - end1) / (end2 - end1), 0.0, 1.0);\n  return x * x * x * (x * (x * 6 - 15) + 10);\n};\n\nMobileWidgetControls.prototype.makeDocumentUnselectable = function () {\n  var styleId = 'mobile-widget-controls-style';\n\n  if (!document.getElementById(styleId)) {\n    var head = document.getElementsByTagName('head')[0];\n    var style = document.createElement('style');\n    style.id = styleId;\n    style.innerText = \"\\n            *.noselect {\\n               -webkit-touch-callout: none; /* iOS Safari */\\n                 -webkit-user-select: none; /* Safari */\\n                  -khtml-user-select: none; /* Konqueror HTML */\\n                    -moz-user-select: none; /* Firefox */\\n                     -ms-user-select: none; /* Internet Explorer/Edge */\\n                         user-select: none; /* Non-prefixed version, currently\\n                                               supported by Chrome and Opera */\\n            }\\n        \";\n    head.appendChild(style);\n  }\n\n  document.body.className += ' noselect';\n};\n\n\n\n//# sourceURL=webpack://widget-mobile-controller/./src/MobileWidgetControls.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _MobileWidgetCameraControls__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MobileWidgetCameraControls */ \"./src/MobileWidgetCameraControls.js\");\n// scene size\n\n // screen size\n\nvar WIDTH = window.innerWidth;\nvar HEIGHT = window.innerHeight; // camera\n\nvar VIEW_ANGLE = 90;\nvar ASPECT = WIDTH / HEIGHT;\nvar NEAR = 0.1; // precision\n\nvar FAR = 5000;\nvar cube;\nvar camera;\nvar scene;\nvar renderer;\nvar controls;\ninit();\nanimate();\n\nfunction init() {\n  var isTouch = 'ontouchstart' in window || navigator.msMaxTouchPoints > 0;\n  if (isTouch) console.log('[main] Touch device detected.');else console.log('[main] This is not a touch device.'); // let container = document.getElementById('container');\n\n  renderer = new three__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderer({\n    antialias: true\n  });\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.setSize(WIDTH, HEIGHT);\n  document.body.appendChild(renderer.domElement);\n  scene = new three__WEBPACK_IMPORTED_MODULE_1__.Scene();\n  scene.background = new three__WEBPACK_IMPORTED_MODULE_1__.Color(0x111111);\n  camera = new three__WEBPACK_IMPORTED_MODULE_1__.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);\n  scene.add(camera);\n  camera.position.set(0, 0, 30);\n  var lights = [];\n  lights[0] = new three__WEBPACK_IMPORTED_MODULE_1__.PointLight(0xffffff, 1, 0);\n  lights[1] = new three__WEBPACK_IMPORTED_MODULE_1__.PointLight(0xffffff, 1, 0);\n  lights[2] = new three__WEBPACK_IMPORTED_MODULE_1__.PointLight(0xffffff, 1, 0);\n  lights[0].position.set(0, 200, 0);\n  lights[1].position.set(100, 200, 100);\n  lights[2].position.set(-100, -200, -100);\n  scene.add(lights[0]);\n  scene.add(lights[1]);\n  scene.add(lights[2]);\n  var g = new three__WEBPACK_IMPORTED_MODULE_1__.TorusKnotBufferGeometry(10, 3, 100, 16);\n  var m = new three__WEBPACK_IMPORTED_MODULE_1__.MeshPhongMaterial({\n    color: 0x2194CE,\n    shininess: 1\n  });\n  cube = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(g, m);\n  scene.add(cube);\n  var ph = new three__WEBPACK_IMPORTED_MODULE_1__.GridHelper(150, 20, 0x00ff00, 0xffffff);\n  ph.position.set(0, -15, 0);\n  scene.add(ph); // Resize renderer.\n\n  var resizeCallback = function resizeCallback() {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n  };\n\n  window.addEventListener('resize', resizeCallback, false);\n  window.addEventListener('orientationchange', resizeCallback, false); // HERE.\n\n  var widget = document.getElementById('widget'); // controls = new MobileWidgetCameraControls(widget, camera, 'quaternion', 'playstation');\n\n  controls = new _MobileWidgetCameraControls__WEBPACK_IMPORTED_MODULE_0__.MobileWidgetCameraControls(widget, camera, 'spherical', 'default');\n  controls.widgetControls.minOpacity = 0.3;\n}\n\nfunction render() {\n  renderer.render(scene, camera);\n}\n\nfunction animate() {\n  requestAnimationFrame(animate); // Update camera rotation and position\n\n  controls.animate(); // Render\n\n  render();\n}\n\n//# sourceURL=webpack://widget-mobile-controller/./src/main.js?");

/***/ })

},
0,[["./src/main.js","runtime","vendors"]]]);